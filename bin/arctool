#!/usr/bin/env python
"""Manage archiving of data."""

import sys
import os
import json

import yaml
import click

import dtool
from dtool import __version__
from dtool.arctool import (
    create_manifest,
    extract_manifest,
    extract_readme,
    new_archive,
    rel_paths_for_archiving,
    summarise_archive,
    readme_yml_is_valid,
)
from dtool.archive import (
    initialise_tar_archive,
    append_to_tar_archive,
    compress_archive,
)
from dtool.slurm import generate_slurm_script

from fluent import sender


@click.group()
@click.version_option(version=__version__)
@click.option('--fluentd-host', envvar='FLUENTD_HOST', default='localhost')
def cli(fluentd_host):
    global logger
    logger = sender.FluentSender('arctool', host=fluentd_host, port=24224)
    logger.emit('version', {'api-version': __version__})


@cli.command()
@click.option('--staging_path',
              help='Path to staging area where new archive will be created',
              default='.',
              type=click.Path(exists=True))
def new(staging_path):

    staging_path = os.path.abspath(staging_path)

    click.secho('Starting new archive in: ', nl=False)
    click.secho(staging_path, fg='green')

    archive_path = new_archive(staging_path)

    click.secho('Created new archive in: ', nl=False)
    click.secho(archive_path, fg='green')

    readme_file = os.path.join(archive_path, 'README.yml')

    with open(readme_file) as fh:
        metadata = yaml.load(fh)

    # Fix problem serializing datetime objects
    metadata['archive_date'] = str(metadata['archive_date'])

    log_data = {'metadata': metadata,
                'archive_path': archive_path}
    logger.emit('new', log_data)

    archive_data_path = os.path.join(archive_path, 'archive')

    click.secho('Now:')
    click.secho('  1. Edit {}'.format(readme_file), fg='yellow')
    click.secho('  2. Move archive data into {}'.format(archive_data_path),
                fg='yellow')
    click.secho('Then: ', nl=False)
    click.secho('arctool manifest create {}'.format(archive_data_path),
                fg='cyan')


@cli.group()
def manifest():
    pass


@manifest.command()
@click.argument('path', 'Path to archive directory.',
                type=click.Path(exists=True))
def create(path):

    logger.emit('manifest_create', {'path': path})

    manifest_path = create_manifest(path)

    with open(manifest_path) as fh:
        manifest = json.load(fh)

    click.secho('Created manifest: ', nl=False)
    click.secho(manifest_path, fg='green')

    logger.emit('manifest', manifest)

    dataset_path, _ = os.path.split(manifest_path)
    dataset_path = os.path.abspath(dataset_path)
    click.secho('Next: ', nl=False)
    click.secho('arctool archive create {}'.format(dataset_path), fg='cyan')


@cli.group()
def archive():
    pass


@archive.command()  # NOQA
@click.argument('path', 'Path to dataset directory.',
                type=click.Path(exists=True))
def create(path):
    path = os.path.abspath(path)

    pre_tar_log = {'archive_path': path}
    logger.emit('create_archive', pre_tar_log)

    readme_path = os.path.join(path, "README.yml")
    click.secho('Validating readme at: ', nl=False)
    click.secho(readme_path, fg='green')
    readme_str = open(readme_path, "r").read()
    if not readme_yml_is_valid(readme_str):
        click.secho("Not valid", fg='red')
        sys.exit(2)

    manifest_path = os.path.join(path, "manifest.json")
    if not os.path.isfile(manifest_path):
        click.secho("No manifest file found in archive", fg='red')
        sys.exit(2)

    dtool_dataset_path = os.path.join(path, ".dtool-dataset")
    if not os.path.isfile(dtool_dataset_path):
        click.secho("No .dtool-dataset file found in archive", fg='red')
        sys.exit(2)

    with open(manifest_path) as fh:
        manifest = json.load(fh)
    manifest_filedict = manifest['file_list']
    tot_size = sum(entry['size'] for entry in manifest_filedict)

    tar_file_path = dtool.arctool.initialise_archive(path)

    def show_func(item):
        if item is None:
          return ''
        return str(item['path'])

    with click.progressbar(manifest_filedict,
                           length=tot_size,
                           item_show_func=show_func) as bar:
        for entry in bar:
            rpath = os.path.join('archive', entry['path'])
            append_to_tar_archive(path, rpath)
            bar.update(entry['size'])

    click.secho('Archiving data at: ', nl=False)
    click.secho(path, fg='green')

    click.secho('Created archive: ', nl=False)
    click.secho(tar_file_path, fg='green')

    archive_size = os.stat(tar_file_path).st_size
    post_tar_log = {'archive_size': archive_size,
                    'output_tar_path': tar_file_path}
    logger.emit('tar_created', post_tar_log)

    click.secho('Next: ', nl=False)
    click.secho('arctool archive compress {}'.format(tar_file_path), fg='cyan')


@archive.command()
@click.option('--cores', '-c', default=4, help='Number of CPU cores to use.')
@click.option('--slurm', '-s', is_flag=True, default=False,
              help='Rather than running compression, generate SLURM script.')
@click.argument('path', 'Path to uncompressed archive (tar) file.',
                type=click.Path(exists=True))
def compress(path, cores, slurm):
    path = os.path.abspath(path)

    if not slurm:
        click.secho('Compressing archive: ', nl=False)
        click.secho(path, fg='green')

        pre_log = {'archive_path': path,
                   'cores': cores,
                   'tar_size': os.stat(path).st_size}
        logger.emit('compress_archive', pre_log)

        compressed_archive_path = compress_archive(path, n_threads=cores)

        click.secho('Created compressed file: ', nl=False)
        click.secho(compressed_archive_path, fg='green')

        post_log = {'compressed_archive_path': compressed_archive_path,
                    'gzip_size': os.stat(compressed_archive_path).st_size}
        logger.emit('compress_complete', post_log)

        click.secho('Now:')
        click.secho('  Move {} to archive storage'.format(
            compressed_archive_path), fg='yellow')

    # WARNING - be VERY careful automating this to submit the job - if the
    # logic fails, the job will repeatedly submit itself forever!
    else:
        job_parameters = dict(n_cores=cores, partition="rg-sv")
        command_string = "arctool archive compress -c {} {}".format(cores,
                                                                    path)

        submit_string = generate_slurm_script(command_string, job_parameters)

        print(submit_string)


@cli.group()
def verify():
    pass


@verify.command()
@click.argument('path', 'Path to compressed archive.',
                type=click.Path(exists=True))
def summary(path):
    summary_data = summarise_archive(path)

    size_in_gibi = float(summary_data['total_size']) / (2 ** 30)

    click.secho("Archive contains", nl=False)
    click.secho(" {} ".format(summary_data['n_files']), fg='green', nl=False)
    click.secho("files.")

    click.secho("Total uncompressed archive size is", nl=False)
    click.secho(" {:.2f} GiB".format(size_in_gibi), fg='green', nl=False)
    click.secho(".")


@cli.group()
def extract():
    pass


@extract.command()
@click.argument('path', 'Path to compressed archive.',
                type=click.Path(exists=True))
def manifest(path):
    extracted_manifest_path = extract_manifest(path)
    click.secho('Extracted ', nl=False)
    click.secho(extracted_manifest_path, fg='green')


@extract.command()
@click.argument('path', 'Path to compressed archive.',
                type=click.Path(exists=True))
def readme(path):
    extracted_readme_path = extract_readme(path)
    click.secho('Extracted ', nl=False)
    click.secho(extracted_readme_path, fg='green')


@extract.command()
@click.argument('path', 'Path to compressed archive.',
                type=click.Path(exists=True))
def metadata(path):
    extracted_readme_path = extract_readme(path)
    click.secho('Extracted ', nl=False)
    click.secho(extracted_readme_path, fg='green')
    extracted_manifest_path = extract_manifest(path)
    click.secho('Extracted ', nl=False)
    click.secho(extracted_manifest_path, fg='green')


if __name__ == "__main__":
    cli()
